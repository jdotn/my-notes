Q.プリミティブ型のデータの内、Boolean、Number、BigInt、String、
Symbolなどが何故オブジェクトのメソッドを呼び出せる?
A.それぞれのプリミティブ型に対応するオブジェクトがあり、
これをラッパーオブジェクトと呼ぶ。
const str = 'string';
str.toUpperCase();
とできるのは、
(new String(str)).toUpperCase();
のような暗黙的な型変換が行われているから。

Q.スコープってなんぞ?
A.変数の名前や関数などの参照できる範囲を決めるもの。
スコープの中で定義された変数はスコープ内でのみ参照できる。

ES6(2015)より前は、JavaScriptにブロックスコープはなかった。
かつてはグローバルスコープと関数スコープがあった。
ES6でletとconstというキーワードが追加された。これらはブロック
スコープを提供する。
ブロックとは{}によって囲まれた範囲。
グローバルスコープ
varで宣言された変数は常にグローバルスコープを持ち、
ブロックスコープを持つことはできない。
letで定義された変数は再宣言することはできない。
let x = "John Doe";
let x = 0;
のようなことはできない。
JavaScriptには
・ブロックスコープ
・関数スコープ
・グローバルスコープ
の3種類が存在する。

グローバルスコープには自分で定義したグローバル変数以外に、
プログラム実行時に自動的に定義されるビルトインオブジェクトがある。
ビルトインオブジェクトは主に2種類
1. undefinedのような変数やisNaNのような関数、ArrayやRegExpなどの
コンストラクタ関数
2. 実行環境(ブラウザやNode.jsなど)が定義するオブジェクト
たとえばdocumentやmoduleなど


JavaScriptオブジェクトを表示すると[object Object]が出力される。
Q.呼び出し方は?
1.person.nameなどプロパティ名で呼び出す
2.ループ変数でオブジェクトのプロパティを表示
 for (let x in person) {
  text += person[x] + " ";
}
3.Object.values()を使用する
これによって配列が生成される
const myArray = Object.values(person);
4.JSON.stringify()を使用する
JavaScriptオブジェクトはJSONメソッドを使用して
文字列に変換可能.主要なブラウザで使用可能.
ただし結果はJSON表記になる.

Q.ホイスティング(巻き上げ)とは何?
インタープリターがコードの実行前に関数や変数、クラス、インポートの
宣言をそのスコープの先頭に移動するように見えるプロセスのこと。

Q.importされたファイルはどうなる？
importされたファイル(モジュール)は評価される。
例えばimportするモジュールにconsole.log()があれば、
import時に評価され、表示される。

Q.複数のモジュールから一つのモジュールがimportされている場合は?
同じモジュールの評価は一度だけ行われる。
2回評価されることはない。

Q.importは何種類ある?
4種類。
名前付きimport    : import { export1, export2 } from "module-name";
デフォルトのimport: import defaultExport from "module-name";
名前空間のimport  : import * as name from "module-name";
副作用のimport    : import "module-name";

名前付き:exportしているモジュールで付けられた名前を使ってimport可能。
実際にはデフォルトのimportと同様に独自に名前をつけることも可能。
import { Hoge as Myname } from "hogehoge.js";

デフォルト:デフォルトのexportは名前を明示していないので、任意の名前を
与えることができる。
import tekitou from "/modules/my-module.js";

名前空間のimport: 以下のコードは/modules/my-module.jsにあるモジュールが
exportする全ての値を含んだmyModuleを現在のスコープに追加する。
import * as myModule from "/modules/my-module.js";

この場合myModuleは名前空間オブジェクトを表す。名前空間オブジェクトはexport
されている全ての値をプロパティとして保持している。
import * from "module-name";のようなワイルドカードimportは提供されていない。
高確率で名前の衝突が起こるためである。

副作用のためだけのモジュールimport:
副作用のためだけにモジュール全体をimportした場合、何もimportされない。
モジュールのグローバルなコードが実行されるだけで、値はimportされない。
import "/modules/my-module.js";
この種のimportはしばしばポリフィルのために用いられる。
※ポリフィルはグローバル変数を書き換えるから。



